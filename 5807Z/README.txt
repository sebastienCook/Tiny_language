/*
*	Project 5807 Z
*		author: Sebastien Cook
*		date: April 14 2020
*/

*********************************
*** Project Folder Structure ****
*********************************

README -> Contains the project folder structure and instructions to run the project 
Tiny_Language.dox -> Contains the nuances of the tiny language, as well as the decisions made 
Compiler -> Folder that contains the scanner, parser, interpreter and code generator code
	- makefile -> compiles everything needed to run
	- Scanner.l -> Scanner implementation 
	- Parser.y -> Parser implementation. Also calls the interpreter and code generator. For the sake of demo it calls both so you don’t have to reconfigure every test program you run
	- DST.c -> DST node, refactor and pretty printer implementation. Also contains the symbol table implementation
	- semantic_analysis.c -> Semantic analysis implementation
	- P_code_machine.c -> p_code generation and interpretation implementation
	- codeGeneration.c -> Code generation implementation
	- Test_Programs -> This folder contains sample programs for testing and demonstration
Processor_verilog -> Folder contains the Verilog project and sample program generated code
	- Tiny_language_processor -> Verilog project
	- GeneratedCode -> contains the sample program generated code
	- code_generated.mem -> DO NOT REMOVE!! used by the Verilog project. This is the program it will run. Only replace file with the same name file generated by the compiler.

*********************************
********** HOW TO RUN ***********
*********************************

Compiler: 

1. open terminal in Compiler folder
2. enter command make
3. Run the program by typing: 
	./a_out Test_programs/NAME_OF_FILE.txt
	or if you have a personal test in the same directory as the rest
	./a_out NAME_OF_FILE.txt 


Verilog Project: 

This project was created using Vivado 2016.4 (The version used at Carleton University on the lab machines) 

The Verilog project requires Vivado to run. Running the behavioural simulation in Vivado yields the nicest results since I've added "peek wires" that peek into the system at key locations to generate a nice simulation display at every time step rather than only offer the final result.

1. Open the project in Vivado by either opening it through Vivado or double clicking Tiny_language.processor.xpr
2. Once the project is open in Vivado, check Sim_1/Memory File/Code_generated.mem 
	- if there is a red question mark follow ADD Code Generated file instructions before continuing 
3. In the flow navigator, select Run Simulation -> Behavioural simulation
4. A new tab of the simulation will be added in your workspace. Select it to see the visual representation of the values
5. The ultimate check to verify that it functioned properly, in the Scope window, select uP -> ram0. Then in the Objects window, select data_mem and scroll all the way down to address 0. This is the stack. If all ran correctly, the return value you expect should be in address 0. 

ADD Code Generated file:

1. right click on sim_1 and select Add Sources
2. in the new window select Add or create simulation sources
3. select the green plus on the left and Add Files. Then select Code_generated.mem



NOTE:  I’d like to mention that no print command was added in the tiny language. This is a feature I regret not adding and can no longer add due to time constraints. This means that a program can only output one final answer, severely limiting the flexibility of the tiny language. Given time, I would implement the print function as follows:
	1.	Add a print key word and token in the scanner
	2.	In the parser I’d add the pattern “Print LP expression RP SC” which amounts to print(x); or print(x+3); or print(function call);
		Note: The print statement will only print integers, remaining in the spirit of the tiny language.
	3.	This would be added as a node in the DST with the expression pointed to by down.
	4.	During interpretation of P_code, when a print statement is encountered, it will utilize printf from the C library and print the item at the top of the stack. And reduce Sp by one. 


